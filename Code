#include <Wire.h>
#include <WiFi.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include "FastIMU.h"

// WiFi Credentials
const char* ssid = "22";
const char* password = "********";

// Custom I2C pins
#define I2C_SDA 21
#define I2C_SCL 22

// Buzzer pin (use PWM instead of DAC for simpler audio)
#define BUZZER_PIN 25

// MPU6500 setup
#define IMU_ADDRESS 0x68
MPU6500 mpu;
calData calib = { 0 };
AccelData accelData;
GyroData gyroData;

WebServer server(80);
WebSocketsServer webSocket = WebSocketsServer(81);

// Motion tracking variables
float accelX, accelY, accelZ;
float gyroX, gyroY, gyroZ;
String currentChord = "C Major";
unsigned long lastChordChange = 0;
unsigned long lastStrumTime = 0;
bool wasStrumming = false;

// Chord detection thresholds
const float STRUM_THRESHOLD = 1.8;        // Increased threshold
const float CHORD_CHANGE_COOLDOWN = 200;
const unsigned long STRUM_COOLDOWN = 300;  // Prevent rapid re-triggers

int currentChordIndex = 0;

// Chord frequencies for buzzer
const int chordBaseFreq[] = {262, 196, 294, 330, 220, 175, 294};

// Timing
unsigned long lastSensorUpdate = 0;
unsigned long lastWebSocketBroadcast = 0;
const int SENSOR_UPDATE_INTERVAL = 10;    // 100Hz sensor reading
const int WEBSOCKET_BROADCAST_INTERVAL = 30; // ~33Hz broadcast

// HTML with WebSocket, Web Audio API, and improved 3D guitar
const char webpage[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ESP32 Air Guitar - Live Dashboard</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
  color: #fff;
  min-height: 100vh;
  overflow-x: hidden;
}
.container { max-width: 1400px; margin: 0 auto; padding: 15px; }
header {
  text-align: center;
  padding: 20px 0;
  border-bottom: 2px solid rgba(255,215,0,0.3);
  margin-bottom: 15px;
}
h1 {
  font-size: 2.5em;
  background: linear-gradient(90deg, #ffd700, #ff6b6b, #ffd700);
  background-size: 200% auto;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: shimmer 3s linear infinite;
}
@keyframes shimmer {
  to { background-position: 200% center; }
}
.status-bar {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 10px;
  font-size: 0.9em;
}
.status-item {
  display: flex;
  align-items: center;
  gap: 6px;
}
.dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}
.dot.green { background: #00ff00; box-shadow: 0 0 10px #00ff00; }
.dot.red { background: #ff0000; box-shadow: 0 0 10px #ff0000; }
.dot.yellow { background: #ffff00; box-shadow: 0 0 10px #ffff00; }
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.9); }
}
.main-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 15px;
  margin-bottom: 15px;
}
.card {
  background: rgba(255,255,255,0.08);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(255,255,255,0.1);
}
.card-title {
  font-size: 1.1em;
  color: #ffd700;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 8px;
}
#guitarCanvas {
  width: 100%;
  height: 380px;
  display: block;
}
.chord-section { text-align: center; }
.current-chord {
  font-size: 4em;
  font-weight: 800;
  color: #ffd700;
  text-shadow: 0 0 30px rgba(255,215,0,0.5);
  margin: 10px 0;
  transition: all 0.2s;
}
.current-chord.strumming {
  transform: scale(1.1);
  color: #ff6b6b;
  text-shadow: 0 0 50px rgba(255,100,100,0.8);
}
.chord-notes {
  font-size: 1.2em;
  opacity: 0.7;
  margin-bottom: 15px;
}
.stats-row {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  margin-top: 15px;
}
.stat {
  background: rgba(0,0,0,0.3);
  padding: 12px 8px;
  border-radius: 10px;
  text-align: center;
}
.stat-val {
  font-size: 1.6em;
  font-weight: 700;
  color: #4ecdc4;
  font-family: 'Courier New', monospace;
}
.stat-lbl {
  font-size: 0.7em;
  opacity: 0.6;
  text-transform: uppercase;
  margin-top: 3px;
}
.graphs-row {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
}
.graph-card {
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  padding: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}
.graph-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
}
.graph-title { font-weight: 600; }
.graph-val { font-family: monospace; font-weight: 700; }
.graph-canvas {
  width: 100%;
  height: 150px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
}
.audio-controls {
  background: rgba(255,100,100,0.1);
  border: 1px solid rgba(255,100,100,0.3);
  border-radius: 12px;
  padding: 15px;
  margin-top: 15px;
  text-align: center;
}
.audio-btn {
  background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
  border: none;
  color: white;
  padding: 12px 30px;
  border-radius: 25px;
  font-size: 1.1em;
  cursor: pointer;
  transition: all 0.3s;
}
.audio-btn:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(255,100,100,0.4); }
.audio-btn.active { background: linear-gradient(135deg, #4ecdc4, #44a08d); }
.latency-display {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(0,0,0,0.7);
  padding: 8px 15px;
  border-radius: 20px;
  font-size: 0.8em;
  font-family: monospace;
}
@media (max-width: 900px) {
  .main-grid { grid-template-columns: 1fr; }
  .graphs-row { grid-template-columns: 1fr; }
  .stats-row { grid-template-columns: repeat(2, 1fr); }
}
</style>
</head>
<body>
<div class="container">
<header>
<h1>üé∏ ESP32 Air Guitar</h1>
<div class="status-bar">
<div class="status-item"><span class="dot green" id="wsDot"></span><span id="wsStatus">Connecting...</span></div>
<div class="status-item"><span class="dot yellow" id="audioDot"></span><span id="audioStatus">Audio Off</span></div>
<div class="status-item">üìä <span id="fps">0</span> FPS</div>
</div>
</header>

<div class="main-grid">
<div class="card">
<div class="card-title">üéÆ 3D Guitar Visualization</div>
<canvas id="guitarCanvas"></canvas>
</div>

<div class="card chord-section">
<div class="card-title">üéµ Current Chord</div>
<div class="current-chord" id="chordDisplay">--</div>
<div class="chord-notes" id="chordNotes">Waiting for data...</div>

<div class="audio-controls">
<button class="audio-btn" id="audioBtn" onclick="toggleAudio()">üîä Enable Browser Audio</button>
<p style="margin-top:10px;opacity:0.7;font-size:0.85em;">Click to enable sound (required by browsers)</p>
</div>

<div class="stats-row">
<div class="stat"><div class="stat-val" id="accelMag">0.00</div><div class="stat-lbl">Accel (g)</div></div>
<div class="stat"><div class="stat-val" id="gyroMag">0.00</div><div class="stat-lbl">Gyro (¬∞/s)</div></div>
<div class="stat"><div class="stat-val" id="strumCount">0</div><div class="stat-lbl">Strums</div></div>
<div class="stat"><div class="stat-val" id="pitch">0¬∞</div><div class="stat-lbl">Pitch</div></div>
</div>
</div>
</div>

<div class="graphs-row">
<div class="graph-card">
<div class="graph-header">
<span class="graph-title" style="color:#ff6b6b">üìà X-Axis</span>
<span class="graph-val" id="valX" style="color:#ff6b6b">0.00g</span>
</div>
<canvas id="graphX" class="graph-canvas"></canvas>
</div>
<div class="graph-card">
<div class="graph-header">
<span class="graph-title" style="color:#4ecdc4">üìà Y-Axis</span>
<span class="graph-val" id="valY" style="color:#4ecdc4">0.00g</span>
</div>
<canvas id="graphY" class="graph-canvas"></canvas>
</div>
<div class="graph-card">
<div class="graph-header">
<span class="graph-title" style="color:#ffe66d">üìà Z-Axis</span>
<span class="graph-val" id="valZ" style="color:#ffe66d">0.00g</span>
</div>
<canvas id="graphZ" class="graph-canvas"></canvas>
</div>
</div>
</div>

<div class="latency-display">
Latency: <span id="latency">--</span>ms | Updates: <span id="updateRate">0</span>/s
</div>

<script>
// WebSocket connection
let ws;
let wsConnected = false;
let audioEnabled = false;
let audioCtx;
let strumCount = 0;
let lastStrumTime = 0;

// Graph data
const maxPoints = 80;
let dataX = [], dataY = [], dataZ = [];

// Guitar rotation
let rotX = 0, rotY = 0, rotZ = 0;
let targetRotX = 0, targetRotY = 0, targetRotZ = 0;
let strumAnim = 0;

// Performance tracking
let frameCount = 0;
let lastFpsTime = Date.now();
let updateCount = 0;
let lastUpdateTime = Date.now();

// Chord definitions with frequencies
const chords = {
  'C Major': { notes: 'C - E - G', freqs: [261.63, 329.63, 392.00], color: '#ff6b6b' },
  'G Major': { notes: 'G - B - D', freqs: [196.00, 246.94, 293.66], color: '#4ecdc4' },
  'D Major': { notes: 'D - F# - A', freqs: [293.66, 369.99, 440.00], color: '#ffe66d' },
  'E Minor': { notes: 'E - G - B', freqs: [329.63, 392.00, 493.88], color: '#a8e6cf' },
  'A Minor': { notes: 'A - C - E', freqs: [220.00, 261.63, 329.63], color: '#dda0dd' },
  'F Major': { notes: 'F - A - C', freqs: [174.61, 220.00, 261.63], color: '#98d8c8' },
  'Dm': { notes: 'D - F - A', freqs: [293.66, 349.23, 440.00], color: '#f7dc6f' }
};

// Initialize WebSocket
function connectWebSocket() {
  const wsUrl = 'ws://' + window.location.hostname + ':81';
  ws = new WebSocket(wsUrl);
  
  ws.onopen = () => {
    wsConnected = true;
    document.getElementById('wsDot').className = 'dot green';
    document.getElementById('wsStatus').textContent = 'Connected';
    console.log('WebSocket connected');
  };
  
  ws.onclose = () => {
    wsConnected = false;
    document.getElementById('wsDot').className = 'dot red';
    document.getElementById('wsStatus').textContent = 'Disconnected';
    setTimeout(connectWebSocket, 2000);
  };
  
  ws.onerror = (e) => {
    console.error('WebSocket error:', e);
  };
  
  ws.onmessage = (event) => {
    const startTime = performance.now();
    try {
      const data = JSON.parse(event.data);
      processData(data);
      
      const latency = (performance.now() - startTime).toFixed(1);
      document.getElementById('latency').textContent = latency;
      
      updateCount++;
    } catch(e) {
      console.error('Parse error:', e);
    }
  };
}

function processData(data) {
  // Update displays
  const chordEl = document.getElementById('chordDisplay');
  chordEl.textContent = data.chord;
  
  const chordInfo = chords[data.chord] || chords['C Major'];
  document.getElementById('chordNotes').textContent = chordInfo.notes;
  chordEl.style.color = chordInfo.color;
  
  document.getElementById('accelMag').textContent = data.accelMag.toFixed(2);
  document.getElementById('gyroMag').textContent = data.gyroMag.toFixed(1);
  
  document.getElementById('valX').textContent = data.accelX.toFixed(2) + 'g';
  document.getElementById('valY').textContent = data.accelY.toFixed(2) + 'g';
  document.getElementById('valZ').textContent = data.accelZ.toFixed(2) + 'g';
  
  // Calculate pitch
  const pitch = Math.atan2(data.accelY, Math.sqrt(data.accelX**2 + data.accelZ**2)) * 180 / Math.PI;
  document.getElementById('pitch').textContent = pitch.toFixed(0) + '¬∞';
  
  // Update graph data
  dataX.push(data.accelX);
  dataY.push(data.accelY);
  dataZ.push(data.accelZ);
  if (dataX.length > maxPoints) { dataX.shift(); dataY.shift(); dataZ.shift(); }
  
  // Update guitar rotation targets
  targetRotX = data.gyroX * 0.02;
  targetRotY = data.gyroY * 0.02;
  targetRotZ = data.accelX * 0.3;
  
  // Handle strum
  if (data.strum) {
    const now = Date.now();
    if (now - lastStrumTime > 250) {
      strumCount++;
      document.getElementById('strumCount').textContent = strumCount;
      strumAnim = 1;
      lastStrumTime = now;
      
      chordEl.classList.add('strumming');
      setTimeout(() => chordEl.classList.remove('strumming'), 200);
      
      if (audioEnabled) {
        playChordSound(chordInfo.freqs);
      }
    }
  }
}

// Web Audio API - plays on laptop/phone speakers!
function toggleAudio() {
  const btn = document.getElementById('audioBtn');
  const dot = document.getElementById('audioDot');
  const status = document.getElementById('audioStatus');
  
  if (!audioEnabled) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioEnabled = true;
    btn.textContent = 'üîá Disable Audio';
    btn.classList.add('active');
    dot.className = 'dot green';
    status.textContent = 'Audio On';
    
    // Play a test tone
    playChordSound([440], 0.3);
  } else {
    audioEnabled = false;
    btn.textContent = 'üîä Enable Browser Audio';
    btn.classList.remove('active');
    dot.className = 'dot yellow';
    status.textContent = 'Audio Off';
  }
}

function playChordSound(frequencies, duration = 0.5) {
  if (!audioCtx || !audioEnabled) return;
  
  const now = audioCtx.currentTime;
  
  frequencies.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = 'triangle'; // Softer guitar-like tone
    osc.frequency.setValueAtTime(freq, now);
    
    // ADSR envelope
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.15, now + 0.02);  // Attack
    gain.gain.linearRampToValueAtTime(0.1, now + 0.1);    // Decay
    gain.gain.linearRampToValueAtTime(0.08, now + duration * 0.7); // Sustain
    gain.gain.linearRampToValueAtTime(0, now + duration); // Release
    
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.start(now);
    osc.stop(now + duration);
  });
}

// Canvas setup
const guitarCanvas = document.getElementById('guitarCanvas');
const gCtx = guitarCanvas.getContext('2d');
const graphX = document.getElementById('graphX');
const graphY = document.getElementById('graphY');
const graphZ = document.getElementById('graphZ');

function resizeCanvases() {
  guitarCanvas.width = guitarCanvas.offsetWidth;
  guitarCanvas.height = guitarCanvas.offsetHeight;
  [graphX, graphY, graphZ].forEach(c => {
    c.width = c.offsetWidth;
    c.height = c.offsetHeight;
  });
}
resizeCanvases();
window.addEventListener('resize', resizeCanvases);

// Draw 3D Guitar
function drawGuitar() {
  const w = guitarCanvas.width, h = guitarCanvas.height;
  const cx = w / 2, cy = h / 2 + 30;
  
  gCtx.clearRect(0, 0, w, h);
  
  // Smooth rotation
  rotX += (targetRotX - rotX) * 0.1;
  rotY += (targetRotY - rotY) * 0.1;
  rotZ += (targetRotZ - rotZ) * 0.15;
  
  gCtx.save();
  gCtx.translate(cx, cy);
  
  // 3D perspective effect
  const perspective = 1 + rotY * 0.1;
  const tiltX = rotZ * 20;
  const tiltY = rotX * 15;
  
  gCtx.transform(perspective, rotX * 0.1, rotY * 0.1, 1, tiltX, tiltY);
  
  // Guitar shadow
  gCtx.fillStyle = 'rgba(0,0,0,0.3)';
  gCtx.beginPath();
  gCtx.ellipse(8, 12, 95, 115, 0.1, 0, Math.PI * 2);
  gCtx.fill();
  
  // Guitar body
  const bodyGrad = gCtx.createRadialGradient(-20, -20, 10, 0, 0, 120);
  bodyGrad.addColorStop(0, '#CD853F');
  bodyGrad.addColorStop(0.5, '#8B4513');
  bodyGrad.addColorStop(1, '#5D3A1A');
  gCtx.fillStyle = bodyGrad;
  gCtx.beginPath();
  gCtx.ellipse(0, 0, 90, 110, 0, 0, Math.PI * 2);
  gCtx.fill();
  
  // Body edge highlight
  gCtx.strokeStyle = 'rgba(255,215,0,0.3)';
  gCtx.lineWidth = 2;
  gCtx.stroke();
  
  // Sound hole
  const holeGrad = gCtx.createRadialGradient(0, 5, 0, 0, 5, 45);
  holeGrad.addColorStop(0, '#1a1a1a');
  holeGrad.addColorStop(1, '#000');
  gCtx.fillStyle = holeGrad;
  gCtx.beginPath();
  gCtx.ellipse(0, 5, 40, 45, 0, 0, Math.PI * 2);
  gCtx.fill();
  
  // Sound hole ring
  gCtx.strokeStyle = '#DAA520';
  gCtx.lineWidth = 3;
  gCtx.beginPath();
  gCtx.ellipse(0, 5, 42, 47, 0, 0, Math.PI * 2);
  gCtx.stroke();
  
  gCtx.strokeStyle = '#B8860B';
  gCtx.lineWidth = 1;
  gCtx.beginPath();
  gCtx.ellipse(0, 5, 50, 55, 0, 0, Math.PI * 2);
  gCtx.stroke();
  
  // Neck
  const neckGrad = gCtx.createLinearGradient(-18, 0, 18, 0);
  neckGrad.addColorStop(0, '#4a3728');
  neckGrad.addColorStop(0.5, '#6b4423');
  neckGrad.addColorStop(1, '#4a3728');
  gCtx.fillStyle = neckGrad;
  gCtx.fillRect(-18, -230, 36, 150);
  
  // Fretboard
  gCtx.fillStyle = '#2d1f14';
  gCtx.fillRect(-15, -230, 30, 150);
  
  // Frets
  gCtx.strokeStyle = '#C0C0C0';
  gCtx.lineWidth = 2;
  for (let i = 0; i < 6; i++) {
    const y = -210 + i * 25;
    gCtx.beginPath();
    gCtx.moveTo(-15, y);
    gCtx.lineTo(15, y);
    gCtx.stroke();
  }
  
  // Fret markers
  gCtx.fillStyle = '#F5F5DC';
  [2, 4].forEach(i => {
    gCtx.beginPath();
    gCtx.arc(0, -210 + i * 25 + 12, 3, 0, Math.PI * 2);
    gCtx.fill();
  });
  
  // Headstock
  gCtx.fillStyle = '#3d2817';
  gCtx.beginPath();
  gCtx.moveTo(-20, -230);
  gCtx.lineTo(-25, -270);
  gCtx.lineTo(25, -270);
  gCtx.lineTo(20, -230);
  gCtx.closePath();
  gCtx.fill();
  
  // Strings with strum animation
  const stringColors = ['#E8E8E8', '#D3D3D3', '#C0C0C0', '#A9A9A9', '#909090', '#808080'];
  for (let i = 0; i < 6; i++) {
    const x = -10 + i * 4;
    const vibAmp = strumAnim * 8 * (1 - i * 0.1);
    const vibFreq = 0.015 + i * 0.003;
    
    gCtx.strokeStyle = stringColors[i];
    gCtx.lineWidth = 1.5 - i * 0.15;
    gCtx.beginPath();
    gCtx.moveTo(x, -265);
    
    // Draw vibrating string
    for (let y = -265; y <= 100; y += 5) {
      const progress = (y + 265) / 365;
      const vibration = Math.sin(Date.now() * vibFreq + i + y * 0.05) * vibAmp * Math.sin(progress * Math.PI);
      gCtx.lineTo(x + vibration, y);
    }
    gCtx.stroke();
  }
  
  // Bridge
  gCtx.fillStyle = '#2d1f14';
  gCtx.fillRect(-35, 85, 70, 12);
  
  gCtx.restore();
  
  // Decay strum animation
  if (strumAnim > 0) strumAnim *= 0.95;
  
  frameCount++;
}

// Draw graphs
function drawGraph(canvas, data, color) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const pad = 30;
  
  ctx.clearRect(0, 0, w, h);
  
  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad + (h - 2*pad) * i / 4;
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(w - 10, y);
    ctx.stroke();
  }
  
  // Zero line
  ctx.strokeStyle = 'rgba(255,215,0,0.2)';
  ctx.beginPath();
  ctx.moveTo(pad, h/2);
  ctx.lineTo(w - 10, h/2);
  ctx.stroke();
  
  // Data line
  if (data.length > 1) {
    // Glow effect
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    data.forEach((v, i) => {
      const x = pad + (w - pad - 10) * i / maxPoints;
      const y = h/2 - (v * (h - 2*pad) / 6);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  // Y labels
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '10px monospace';
  ctx.textAlign = 'right';
  [-2, 0, 2].forEach(v => {
    const y = h/2 - (v * (h - 2*pad) / 6);
    ctx.fillText(v + 'g', pad - 5, y + 3);
  });
}

// Animation loop
function animate() {
  drawGuitar();
  drawGraph(graphX, dataX, '#ff6b6b');
  drawGraph(graphY, dataY, '#4ecdc4');
  drawGraph(graphZ, dataZ, '#ffe66d');
  
  // FPS counter
  const now = Date.now();
  if (now - lastFpsTime >= 1000) {
    document.getElementById('fps').textContent = frameCount;
    document.getElementById('updateRate').textContent = updateCount;
    frameCount = 0;
    updateCount = 0;
    lastFpsTime = now;
  }
  
  requestAnimationFrame(animate);
}

// Start
connectWebSocket();
animate();
</script>
</body>
</html>
)rawliteral";

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_CONNECTED:
      Serial.printf("üîå Client #%u connected\n", num);
      break;
    case WStype_DISCONNECTED:
      Serial.printf("‚ùå Client #%u disconnected\n", num);
      break;
  }
}

void setup() {
  Serial.begin(115200);
  delay(500);
  
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë   ESP32 Air Guitar v3.0 - WebSocket  ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
  
  // Setup buzzer pin
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  Serial.println("‚úì Buzzer pin configured (GPIO25)");
  
  // Initialize I2C
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  Serial.println("‚úì I2C initialized (400kHz)");
  
  // Initialize MPU6500
  int err = mpu.init(calib, IMU_ADDRESS);
  
  if (err != 0) {
    Serial.print("‚úó MPU6500 init failed! Error: ");
    Serial.println(err);
    Serial.println("\n‚ö† Check wiring:");
    Serial.println("  VCC ‚Üí 3.3V");
    Serial.println("  GND ‚Üí GND");
    Serial.println("  SDA ‚Üí GPIO21");
    Serial.println("  SCL ‚Üí GPIO22");
    while(1) { delay(1000); }
  }
  
  Serial.println("‚úì MPU6500 initialized");
  mpu.setAccelRange(2);
  mpu.setGyroRange(500);
  
  // Connect to WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("\n‚è≥ Connecting to WiFi");
  
  int attempts = 0;
  while(WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(250);
    Serial.print(".");
    attempts++;
  }
  
  if(WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úì WiFi connected!");
    Serial.print("\nüì± Dashboard URL: http://");
    Serial.println(WiFi.localIP());
    Serial.println("\nüîä Browser audio - no hardware needed!");
    Serial.println("   Just click 'Enable Browser Audio' on the page\n");
  } else {
    Serial.println("\n‚úó WiFi connection failed!");
    ESP.restart();
  }
  
  // Setup WebSocket server
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  Serial.println("‚úì WebSocket server started on port 81");
  
  // Setup HTTP server
  server.on("/", HTTP_GET, []() {
    server.send_P(200, "text/html", webpage);
  });
  
  server.begin();
  Serial.println("‚úì HTTP server started on port 80");
  
  Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Serial.println("        üé∏ System Ready!");
  Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
}

void loop() {
  webSocket.loop();
  server.handleClient();
  
  unsigned long now = millis();
  
  // Read sensor at high rate
  if (now - lastSensorUpdate >= SENSOR_UPDATE_INTERVAL) {
    lastSensorUpdate = now;
    
    mpu.update();
    mpu.getAccel(&accelData);
    mpu.getGyro(&gyroData);
    
    accelX = accelData.accelX;
    accelY = accelData.accelY;
    accelZ = accelData.accelZ;
    gyroX = gyroData.gyroX;
    gyroY = gyroData.gyroY;
    gyroZ = gyroData.gyroZ;
    
    detectChord();
  }
  
  // Broadcast via WebSocket at controlled rate
  if (now - lastWebSocketBroadcast >= WEBSOCKET_BROADCAST_INTERVAL) {
    lastWebSocketBroadcast = now;
    broadcastData();
  }
}

void detectChord() {
  unsigned long now = millis();
  if (now - lastChordChange < CHORD_CHANGE_COOLDOWN) return;
  
  float pitch = atan2(accelY, sqrt(accelX*accelX + accelZ*accelZ)) * 180.0 / PI;
  float roll = atan2(accelX, accelZ) * 180.0 / PI;
  
  int newChordIndex = currentChordIndex;
  String newChord = currentChord;
  
  if (abs(pitch) < 15 && abs(roll) < 20) {
    newChord = "C Major"; newChordIndex = 0;
  } else if (pitch > 25) {
    newChord = "G Major"; newChordIndex = 1;
  } else if (pitch < -25) {
    newChord = "D Major"; newChordIndex = 2;
  } else if (roll > 30) {
    newChord = "E Minor"; newChordIndex = 3;
  } else if (roll < -30) {
    newChord = "A Minor"; newChordIndex = 4;
  } else if (pitch > 15 && roll > 15) {
    newChord = "F Major"; newChordIndex = 5;
  } else if (pitch < -10 && roll < -10) {
    newChord = "Dm"; newChordIndex = 6;
  }
  
  if (newChord != currentChord) {
    currentChord = newChord;
    currentChordIndex = newChordIndex;
    lastChordChange = now;
  }
}

void broadcastData() {
  float accelMag = sqrt(accelX*accelX + accelY*accelY + accelZ*accelZ);
  float gyroMag = sqrt(gyroX*gyroX + gyroY*gyroY + gyroZ*gyroZ);
  
  unsigned long now = millis();
  bool strum = false;
  
  // Better strum detection with cooldown
  if (accelMag > STRUM_THRESHOLD && !wasStrumming && (now - lastStrumTime > STRUM_COOLDOWN)) {
    strum = true;
    lastStrumTime = now;
    wasStrumming = true;
    
    // Quick beep on buzzer (optional hardware feedback)
    tone(BUZZER_PIN, chordBaseFreq[currentChordIndex], 100);
  }
  
  if (accelMag < STRUM_THRESHOLD * 0.7) {
    wasStrumming = false;
  }
  
  // Build JSON
  String json = "{";
  json += "\"accelX\":" + String(accelX, 2) + ",";
  json += "\"accelY\":" + String(accelY, 2) + ",";
  json += "\"accelZ\":" + String(accelZ, 2) + ",";
  json += "\"gyroX\":" + String(gyroX, 1) + ",";
  json += "\"gyroY\":" + String(gyroY, 1) + ",";
  json += "\"gyroZ\":" + String(gyroZ, 1) + ",";
  json += "\"accelMag\":" + String(accelMag, 2) + ",";
  json += "\"gyroMag\":" + String(gyroMag, 1) + ",";
  json += "\"chord\":\"" + currentChord + "\",";
  json += "\"strum\":" + String(strum ? "true" : "false");
  json += "}";
  
  webSocket.broadcastTXT(json);
}
